#!/usr/local/bin/perl

use strict;
use warnings FATAL => 'all';

use Cwd ();
use Getopt::Long;
use Try::Tiny;
use Data::Dumper;

use AppConfig (qw( :expand :argcount ));

use File::Spec::Functions (qw( catdir catfile ));
use File::HomeDir ();
use File::Path qw( make_path );
use File::Copy;

use Module::Cooker;

my $VERSION = '0.1_1';

my $homedir;
my $mc_dir = try {
    return unless $homedir = File::HomeDir->my_home;

    my $path = catfile( $homedir, 'modcook' );
    return -d $path ? $path : undef;
}
catch {
    warn "NOTICE: Can not get user's home directory: $_\n";
    return;
};
warn "NOTICE: ~/modcook directory does not exist\n" unless $mc_dir;

# anything not in this hash is meant to be a modcooker param as opposed
# to being a param passed to the M::C constructor.
my %mc_params = (
    minperl   => undef,
    package   => undef,
    version   => undef,
    author    => undef,
    email     => undef,
    profile   => undef,
    nosubs    => undef,
    localdirs => undef,
    extravars => undef,
);

my $cfg = AppConfig->new(
    { ERROR => \&_cfg_error },
    qw(
      minperl=s
      package=s
      version=s
      author=s
      email=s
      profile=s
      nosubs
      extravars=s% )
);

# this has to be defined here because of the EXPAND arg to it
$cfg->define( 'localdirs=s@' => { EXPAND => EXPAND_UID } );

# read a local config file if it exists
if ($mc_dir) {
    my $cfg_fname = catfile( $mc_dir, 'modcooker.cfg' );
    try {
        $cfg->file($cfg_fname);
    }
    catch {
        warn "Config file fatal error\n";
        die $_;
    }
    if -f $cfg_fname;
}

# get this now before checking the command line
my @initial_dirs = @{ $cfg->localdirs };

# it makes no sense to have these defined other than as command line options.
# they will throw an exception if found in the config file.
$cfg->define( 'setup'     => { ARGCOUNT => ARGCOUNT_NONE } );
$cfg->define( 'available' => { ARGCOUNT => ARGCOUNT_NONE } );
$cfg->define( 'copy'      => { ARGS     => '=s', ARGCOUNT => ARGCOUNT_ONE } );

# add in anything from the command line
# NOTE: hashref args (i.e. extravars) do NOT work due to a bug in AppConfig
try {
    $cfg->getopt();
}
catch {
    warn "Command line fatal error\n";
    die $_;
};

my %cfgopts = $cfg->varlist("^.+");

# this addresses a major drawback with other config files namely, they
# don't usually provide a way to override an array
if ( grep( /^replace$/, @{ $cfgopts{localdirs} } ) ) {
    shift( @{ $cfgopts{localdirs} } ) for ( 1 .. @initial_dirs );
    my @tmp = grep !/^replace$/, @{ $cfgopts{localdirs} };
    $cfgopts{localdirs} = \@tmp;
}

# if 'setup' is true then all we want to do is copy the sample config file
# to '~/modcook' and then exit. Should we also copy the default profile to
# '~/modcook/custom' as a starting point?
if ( $cfgopts{setup} ) {
    die "Must have a user's homedir to do a setup" unless $homedir;

    my $cfg_fname = catfile( $homedir, 'modcook', 'modcooker.cfg' );
    die "$cfg_fname already exists" if -f $cfg_fname;

    # we need to create '~/modcook' if it doesn't exist
    try {
        $mc_dir = catdir( $homedir, 'modcook' );
        make_path($mc_dir) or die $!;
    }
    catch {
        die "Can't make dir $mc_dir: $_";
    }
    unless $mc_dir;

    my $std_cfg = catfile( Module::Cooker->_basename_dir, 'modcooker.cfg' );
    copy( $std_cfg, $cfg_fname ) or die "Can't create $cfg_fname: $!";

    print "$cfg_fname has been created, please edit it as needed.\n";

    exit;
} elsif ( $cfgopts{available} ) {

    print "Searching for Available Profiles\n\n";

    my @localdirs = @{ $cfgopts{localdirs} };

    my $profiles = {};

    print "Search Order:\n";
    for (@localdirs) {
        my $dir = Cwd::realpath($_);
        print "  $dir\n";
        _get_profiles( Cwd::realpath($_), 'local', $profiles );
    }
    my $dir = Cwd::realpath( Module::Cooker->_basename_dir );
    print "  $dir\n";
    _get_profiles( $dir, 'standard', $profiles );
    print "\n";

    my $maxlen = length('Profile');
    for ( keys( %{$profiles} ) ) {
        $maxlen = length($_) if length($_) > $maxlen;
    }
    my $pat1 = "\%-${maxlen}s   - \%s";
    my $pat2 = "  \%-${maxlen}s - \%s";

    printf( "$pat1\n", 'Profile', 'Type' );
    for ( keys( %{$profiles} ) ) {
        printf( "$pat2\n", $_, $profiles->{$_} );
    }

    exit;
} elsif ( $cfgopts{copy} ) {
    # does the standard profile exist?
    my $profiles = {};
    _get_profiles( Module::Cooker->_basename_dir, 'standard', $profiles );
    die "No such standard profile: $cfgopts{copy}"
      unless $profiles->{ $cfgopts{copy} };

    # place the copy in ~/modcook for now, do not overwrite existing files
    # if present, just add to them.

    # we need to create '~/modcook' if it doesn't exist
    try {
        $mc_dir = catdir( $homedir, 'modcook' );
        make_path($mc_dir) or die $!;
    }
    catch {
        die "Can't make dir $mc_dir: $_";
    }
    unless $mc_dir;

    # and create the target profile dir as well, if need be
    my $dest_dir = catdir( $mc_dir, $cfgopts{copy} );
    try {
        make_path($dest_dir) or die $!;
    }
    catch {
        die "Can't make $dest_dir: $_";
    }
    unless -d $dest_dir;

    # now we just copy the source tree, let M::C do the hard work of
    # finding the files themselves
    my $mc = Module::Cooker->new( profile => $cfgopts{copy} );

    # there should be only a single profile dir since localdirs was empty
    my $src_dir = Cwd::realpath( pop( @{ $mc->profile_dirs } ) );
    $mc->_gather_profile( abs_path => $src_dir, subdir_path => undef );

    # create any missing dirs so File::Copy won't complain
    for ( @{ $mc->{_template_dirs} } ) {
        my $dest_subdir = catdir( $dest_dir, $_ );
        try {
            warn "creating subdir: $dest_subdir\n";
            make_path($dest_subdir) or die $!;
        }
        catch {
            die "Can not create $dest_subdir: $_";
        }
        unless -d $dest_subdir;
    }

    for my $template ( keys( %{ $mc->{_templates} } ) ) {
        my $src_path  = catfile( $src_dir,  $template );
        my $dest_path = catfile( $dest_dir, $template );

        if ( -e $dest_path ) {
            warn "Skipping template in $dest_dir: $template\n";
            next;
        }
        warn "Copying $template to $dest_path\n";
        copy( $src_path, $dest_path ) or die "Can't copy $template: $!";
    }

    exit;
}

print "Before:\n";
print 'Options - ' . Dumper( \%cfgopts );
print 'MC params - ' . Dumper( \%mc_params );

for ( keys(%mc_params) ) {
    ( delete( $mc_params{$_} ), next )
      unless defined( $cfgopts{$_} );
    $mc_params{$_} = delete( $cfgopts{$_} );
}

print "\nAfter:\n";
print 'Options - ' . Dumper( \%cfgopts );
print 'MC params - ' . Dumper( \%mc_params );

my $mc = Module::Cooker->new(%mc_params);

print "\nObject values:\n";
print Dumper( \%{ $mc->summary } );
#exit;

$mc->cook();

exit;

sub _cfg_error {
    if ( @_ > 1 ) {
        my $pattern = shift;
        die sprintf( "$pattern\n", @_ );
    } else {
        die "$_[0]\n";
    }
}

sub _get_profiles {
    my ( $dir, $type, $found ) = @_;

    opendir( my $dh, $dir ) or die "can't opendir $dir: $!";
    my @files = readdir($dh);
    closedir $dh;

    for my $fname (@files) {
        next if $fname =~ m{^\.{1,2}\z};

        my $fpath = File::Spec->catfile( $dir, $fname );
        next unless -d $fpath;

        $found->{$fname} = $found->{$fname} ? 'overridden' : $type;
    }

    return;
}

__END__

=head1 NAME

modcooker - Create skeleton module packages from templates

=head1 SYNOPSIS

  
 $ modcooker --package My::New::Module
  

=head1 USAGE

=head2 OPTIONS

=head1 CONFIGURATION FILE

=head1 LOCAL PROFILES

=head1 KNOWN BUGS

Due to L<this bug|https://rt.cpan.org/Public/Bug/Display.html?id=32954> in
L<AppConfig> it is not possible to update values for C<extravars> from the
command line. It has no effect upon setting them in a local config file,
however.

=cut

