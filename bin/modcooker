#!/usr/local/bin/perl

use strict;
use warnings FATAL => 'all';

use lib qw( ../lib );

use Cwd ();
use Getopt::Long;
use Try::Tiny;
use Data::Dumper;

use AppConfig (qw( :expand :argcount ));

use File::Spec::Functions (qw( catdir catfile ));
use File::HomeDir ();
use File::Path qw( make_path );
use File::Copy;

use Module::Cooker;

my $VERSION = '0.1_1';

my $homedir;
my $mc_dir = try {
    return unless $homedir = File::HomeDir->my_home;

    my $path = catfile( $homedir, 'modcook' );
    return -d $path ? $path : undef;
}
catch {
    warn "NOTICE: Can not get user's home directory: $_\n";
    return;
};
warn "NOTICE: ~/modcook directory does not exist\n" unless $mc_dir;

# anything not in this hash is meant to be a modcooker param as opposed
# to being a param passed to the M::C constructor.
my %mc_params = (
    minperl   => undef,
    package   => undef,
    version   => undef,
    author    => undef,
    email     => undef,
    profile   => undef,
    nosubs    => undef,
    localdirs => undef,
    extravars => undef,
);

my $cfg = AppConfig->new(
    { ERROR => \&_cfg_error },
    qw(
      minperl=s
      package=s
      version=s
      author=s
      email=s
      profile=s
      nosubs
      extravars=s% )
);

# this has to be defined here because of the EXPAND arg to it
$cfg->define( 'localdirs=s@' => { EXPAND => EXPAND_UID } );

# read a local config file if it exists
if ( $mc_dir ) {
    my $cfg_fname = catfile( $mc_dir, 'modcooker.cfg' );
    try {
        $cfg->file( $cfg_fname );
    } catch {
        warn "Config file fatal error\n";
        die $_;
    } if -f $cfg_fname;
}

# get this now before checking the command line
my @initial_dirs = @{ $cfg->localdirs };

# it makes no sense to have these defined other than as command line options.
# they will throw an exception if found in the config file.
$cfg->define( 'setup' => { ARGCOUNT => ARGCOUNT_NONE } );
$cfg->define( 'available' => { ARGCOUNT => ARGCOUNT_NONE } );
$cfg->define( 'copy' => { ARGCOUNT => ARGCOUNT_NONE } );

# add in anything from the command line
# NOTE: hashref args (i.e. extravars) do NOT work due to a bug in AppConfig
try {
    $cfg->getopt();
} catch {
    warn "Command line fatal error\n";
    die $_;
};

my %cfgopts = $cfg->varlist("^.+");

# this addresses a major drawback with other config files namely, they
# don't usually provide a way to override an array
if ( grep( /^replace$/, @{ $cfgopts{localdirs} } ) ) {
    shift( @{ $cfgopts{localdirs} } ) for ( 1 .. @initial_dirs );
    my @tmp = grep !/^replace$/, @{ $cfgopts{localdirs} };
    $cfgopts{localdirs} = \@tmp;
}

# if 'setup' is true then all we want to do is copy the sample config file
# to '~/modcook' and then exit. Should we also copy the default profile to
# '~/modcook/custom' as a starting point?
if ( $cfgopts{setup} ) {
    die "Must have a user's homedir to do a setup" unless $homedir;

    my $cfg_fname = catfile( $homedir, 'modcook', 'modcooker.cfg' );
    die "$cfg_fname already exists" if -f $cfg_fname;

    # we need to create '~/modcook' if it doesn't exist
    try {
        $mc_dir = catdir($homedir, 'modcook');
        make_path( $mc_dir ) or die $!;
    } catch {
        die "Can't make dir $mc_dir: $_";
    } unless $mc_dir;

    my $std_cfg = catfile(Module::Cooker->basename_dir,'modcooker.cfg');
    copy($std_cfg,$cfg_fname) or die "Can't create $cfg_fname: $!";

    print "$cfg_fname has been created, please edit it as needed.\n";

    exit;
}
elsif ( $cfgopts{available} ) {

    print "Searching for Available Profiles\n\n";

    my @localdirs = @{$cfgopts{localdirs}};

    my $profiles = {};

    print "Search Order:\n";
    for ( @localdirs ) {
        _get_profiles(Cwd::realpath($_),'local',$profiles);
    }
    _get_profiles(Module::Cooker->_basename_dir,'standard',$profiles);
    print "\n";

    my $maxlen = length('Profile');
    for ( keys(%{$profiles}) ) {
        $maxlen = length($_) if length($_) > $maxlen;
    }
    my $pat1 = "\%-${maxlen}s   - \%s";
    my $pat2 = "  \%-${maxlen}s - \%s";

    printf("$pat1\n",'Profile','Type');
    for ( keys(%{$profiles}) ) {
        printf("$pat2\n",$_,$profiles->{$_});
    }

    exit;
}

print "Before:\n";
print 'Options - ' . Dumper( \%cfgopts );
print 'MC params - ' . Dumper( \%mc_params );

for ( keys(%mc_params) ) {
    ( delete( $mc_params{$_} ), next )
      unless defined( $cfgopts{$_} );
    $mc_params{$_} = delete( $cfgopts{$_} );
}

print "\nAfter:\n";
print 'Options - ' . Dumper( \%cfgopts );
print 'MC params - ' . Dumper( \%mc_params );

my $mc = Module::Cooker->new(%mc_params);

print "\nObject values:\n";
print Dumper( \%{ $mc->summary } );
#exit;

$mc->cook();

exit;

sub _cfg_error {
    if ( @_ > 1 ) {
        my $pattern = shift;
        die sprintf("$pattern\n",@_);
    } else {
        die "$_[0]\n";
    }
}

sub _get_profiles {
    my ($dir,$type,$found) = @_;
    
    print "  $dir\n";

    opendir( my $dh, $dir ) or die "can't opendir $dir: $!";
    my @files = readdir($dh);
    closedir $dh;

    for my $fname (@files) {
        next if $fname =~ m{^\.{1,2}\z};

        my $fpath = File::Spec->catfile( $dir, $fname );

        next unless -d  $fpath;

        $found->{$fname} = $found->{$fname} ? 'overridden': $type;
    }

    return;
}

__END__

=head1 NAME

modcooker - Create skeleton module packages from templates

=head1 SYNOPSIS

  
 $ modcooker --package My::New::Module
  

=head1 USAGE

=head2 OPTIONS

=head1 CONFIGURATION FILE

=head1 LOCAL PROFILES

=head1 KNOWN BUGS

Due to L<this bug|https://rt.cpan.org/Public/Bug/Display.html?id=32954> in
L<AppConfig> it is not possible to update values for C<extravars> from the
command line. It has no effect upon setting them in a local config file,
however.

=cut

